// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DRIVETHRU_BBFRC_MSGS_H_
#define FLATBUFFERS_GENERATED_DRIVETHRU_BBFRC_MSGS_H_

#include "flatbuffers/flatbuffers.h"

namespace bbfrc {
namespace msgs {

struct AnalogReadRequest;

struct AnalogReadResponse;

struct AnalogReadMultiRequest;

struct AnalogReadMultiResponse;

struct AnalogReadSubscribeRequest;

struct AnalogReadSubscribeResponse;

struct AnalogReadSubscribeMultiRequest;

struct AnalogReadSubscribeMultiResponse;

struct DigitalWriteRequest;

struct DigitalReadRequest;

struct DigitalReadResponse;

struct DigitalReadMultiRequest;

struct DigitalReadMultiResponse;

struct DigitalReadSubscribeRequest;

struct DigitalReadSubscribeResponse;

struct DigitalReadSubscribeMultiRequest;

struct DigitalReadSubscribeMultiResponse;

struct SetServoAngleRequest;

struct PinInformation;

struct GetPinInformationRequest;

struct GetPinInformationResponse;

struct GetFirmwareNameAndVersionRequest;

struct GetFirmwareNameAndVersionResponse;

struct SetDigitalPinModeRequest;

struct SystemResetRequest;

struct Envelope;

enum PinMode {
  PinMode_OUTPUT = 0,
  PinMode_INPUT = 1,
  PinMode_INPUT_PULLUP = 2,
  PinMode_ANALOG = 3,
  PinMode_SERVO = 4,
  PinMode_PWM = 5,
  PinMode_MIN = PinMode_OUTPUT,
  PinMode_MAX = PinMode_PWM
};

inline const PinMode (&EnumValuesPinMode())[6] {
  static const PinMode values[] = {
    PinMode_OUTPUT,
    PinMode_INPUT,
    PinMode_INPUT_PULLUP,
    PinMode_ANALOG,
    PinMode_SERVO,
    PinMode_PWM
  };
  return values;
}

inline const char * const *EnumNamesPinMode() {
  static const char * const names[] = {
    "OUTPUT",
    "INPUT",
    "INPUT_PULLUP",
    "ANALOG",
    "SERVO",
    "PWM",
    nullptr
  };
  return names;
}

inline const char *EnumNamePinMode(PinMode e) {
  if (e < PinMode_OUTPUT || e > PinMode_PWM) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPinMode()[index];
}

enum Payload {
  Payload_NONE = 0,
  Payload_AnalogReadRequest = 1,
  Payload_AnalogReadResponse = 2,
  Payload_AnalogReadMultiRequest = 3,
  Payload_AnalogReadMultiResponse = 4,
  Payload_AnalogReadSubscribeRequest = 5,
  Payload_AnalogReadSubscribeResponse = 6,
  Payload_AnalogReadSubscribeMultiRequest = 7,
  Payload_AnalogReadSubscribeMultiResponse = 8,
  Payload_DigitalWriteRequest = 9,
  Payload_DigitalReadRequest = 10,
  Payload_DigitalReadResponse = 11,
  Payload_DigitalReadMultiRequest = 12,
  Payload_DigitalReadMultiResponse = 13,
  Payload_DigitalReadSubscribeRequest = 14,
  Payload_DigitalReadSubscribeResponse = 15,
  Payload_DigitalReadSubscribeMultiRequest = 16,
  Payload_DigitalReadSubscribeMultiResponse = 17,
  Payload_SetServoAngleRequest = 18,
  Payload_GetPinInformationRequest = 19,
  Payload_GetPinInformationResponse = 20,
  Payload_GetFirmwareNameAndVersionRequest = 21,
  Payload_GetFirmwareNameAndVersionResponse = 22,
  Payload_SetDigitalPinModeRequest = 23,
  Payload_SystemResetRequest = 24,
  Payload_MIN = Payload_NONE,
  Payload_MAX = Payload_SystemResetRequest
};

inline const Payload (&EnumValuesPayload())[25] {
  static const Payload values[] = {
    Payload_NONE,
    Payload_AnalogReadRequest,
    Payload_AnalogReadResponse,
    Payload_AnalogReadMultiRequest,
    Payload_AnalogReadMultiResponse,
    Payload_AnalogReadSubscribeRequest,
    Payload_AnalogReadSubscribeResponse,
    Payload_AnalogReadSubscribeMultiRequest,
    Payload_AnalogReadSubscribeMultiResponse,
    Payload_DigitalWriteRequest,
    Payload_DigitalReadRequest,
    Payload_DigitalReadResponse,
    Payload_DigitalReadMultiRequest,
    Payload_DigitalReadMultiResponse,
    Payload_DigitalReadSubscribeRequest,
    Payload_DigitalReadSubscribeResponse,
    Payload_DigitalReadSubscribeMultiRequest,
    Payload_DigitalReadSubscribeMultiResponse,
    Payload_SetServoAngleRequest,
    Payload_GetPinInformationRequest,
    Payload_GetPinInformationResponse,
    Payload_GetFirmwareNameAndVersionRequest,
    Payload_GetFirmwareNameAndVersionResponse,
    Payload_SetDigitalPinModeRequest,
    Payload_SystemResetRequest
  };
  return values;
}

inline const char * const *EnumNamesPayload() {
  static const char * const names[] = {
    "NONE",
    "AnalogReadRequest",
    "AnalogReadResponse",
    "AnalogReadMultiRequest",
    "AnalogReadMultiResponse",
    "AnalogReadSubscribeRequest",
    "AnalogReadSubscribeResponse",
    "AnalogReadSubscribeMultiRequest",
    "AnalogReadSubscribeMultiResponse",
    "DigitalWriteRequest",
    "DigitalReadRequest",
    "DigitalReadResponse",
    "DigitalReadMultiRequest",
    "DigitalReadMultiResponse",
    "DigitalReadSubscribeRequest",
    "DigitalReadSubscribeResponse",
    "DigitalReadSubscribeMultiRequest",
    "DigitalReadSubscribeMultiResponse",
    "SetServoAngleRequest",
    "GetPinInformationRequest",
    "GetPinInformationResponse",
    "GetFirmwareNameAndVersionRequest",
    "GetFirmwareNameAndVersionResponse",
    "SetDigitalPinModeRequest",
    "SystemResetRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNamePayload(Payload e) {
  if (e < Payload_NONE || e > Payload_SystemResetRequest) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPayload()[index];
}

template<typename T> struct PayloadTraits {
  static const Payload enum_value = Payload_NONE;
};

template<> struct PayloadTraits<AnalogReadRequest> {
  static const Payload enum_value = Payload_AnalogReadRequest;
};

template<> struct PayloadTraits<AnalogReadResponse> {
  static const Payload enum_value = Payload_AnalogReadResponse;
};

template<> struct PayloadTraits<AnalogReadMultiRequest> {
  static const Payload enum_value = Payload_AnalogReadMultiRequest;
};

template<> struct PayloadTraits<AnalogReadMultiResponse> {
  static const Payload enum_value = Payload_AnalogReadMultiResponse;
};

template<> struct PayloadTraits<AnalogReadSubscribeRequest> {
  static const Payload enum_value = Payload_AnalogReadSubscribeRequest;
};

template<> struct PayloadTraits<AnalogReadSubscribeResponse> {
  static const Payload enum_value = Payload_AnalogReadSubscribeResponse;
};

template<> struct PayloadTraits<AnalogReadSubscribeMultiRequest> {
  static const Payload enum_value = Payload_AnalogReadSubscribeMultiRequest;
};

template<> struct PayloadTraits<AnalogReadSubscribeMultiResponse> {
  static const Payload enum_value = Payload_AnalogReadSubscribeMultiResponse;
};

template<> struct PayloadTraits<DigitalWriteRequest> {
  static const Payload enum_value = Payload_DigitalWriteRequest;
};

template<> struct PayloadTraits<DigitalReadRequest> {
  static const Payload enum_value = Payload_DigitalReadRequest;
};

template<> struct PayloadTraits<DigitalReadResponse> {
  static const Payload enum_value = Payload_DigitalReadResponse;
};

template<> struct PayloadTraits<DigitalReadMultiRequest> {
  static const Payload enum_value = Payload_DigitalReadMultiRequest;
};

template<> struct PayloadTraits<DigitalReadMultiResponse> {
  static const Payload enum_value = Payload_DigitalReadMultiResponse;
};

template<> struct PayloadTraits<DigitalReadSubscribeRequest> {
  static const Payload enum_value = Payload_DigitalReadSubscribeRequest;
};

template<> struct PayloadTraits<DigitalReadSubscribeResponse> {
  static const Payload enum_value = Payload_DigitalReadSubscribeResponse;
};

template<> struct PayloadTraits<DigitalReadSubscribeMultiRequest> {
  static const Payload enum_value = Payload_DigitalReadSubscribeMultiRequest;
};

template<> struct PayloadTraits<DigitalReadSubscribeMultiResponse> {
  static const Payload enum_value = Payload_DigitalReadSubscribeMultiResponse;
};

template<> struct PayloadTraits<SetServoAngleRequest> {
  static const Payload enum_value = Payload_SetServoAngleRequest;
};

template<> struct PayloadTraits<GetPinInformationRequest> {
  static const Payload enum_value = Payload_GetPinInformationRequest;
};

template<> struct PayloadTraits<GetPinInformationResponse> {
  static const Payload enum_value = Payload_GetPinInformationResponse;
};

template<> struct PayloadTraits<GetFirmwareNameAndVersionRequest> {
  static const Payload enum_value = Payload_GetFirmwareNameAndVersionRequest;
};

template<> struct PayloadTraits<GetFirmwareNameAndVersionResponse> {
  static const Payload enum_value = Payload_GetFirmwareNameAndVersionResponse;
};

template<> struct PayloadTraits<SetDigitalPinModeRequest> {
  static const Payload enum_value = Payload_SetDigitalPinModeRequest;
};

template<> struct PayloadTraits<SystemResetRequest> {
  static const Payload enum_value = Payload_SystemResetRequest;
};

bool VerifyPayload(flatbuffers::Verifier &verifier, const void *obj, Payload type);
bool VerifyPayloadVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct AnalogReadRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PORT = 4
  };
  uint32_t port() const {
    return GetField<uint32_t>(VT_PORT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PORT) &&
           verifier.EndTable();
  }
};

struct AnalogReadRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_port(uint32_t port) {
    fbb_.AddElement<uint32_t>(AnalogReadRequest::VT_PORT, port, 0);
  }
  explicit AnalogReadRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnalogReadRequestBuilder &operator=(const AnalogReadRequestBuilder &);
  flatbuffers::Offset<AnalogReadRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnalogReadRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnalogReadRequest> CreateAnalogReadRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t port = 0) {
  AnalogReadRequestBuilder builder_(_fbb);
  builder_.add_port(port);
  return builder_.Finish();
}

struct AnalogReadResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PORT = 4,
    VT_VALUE = 6
  };
  uint32_t port() const {
    return GetField<uint32_t>(VT_PORT, 0);
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PORT) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct AnalogReadResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_port(uint32_t port) {
    fbb_.AddElement<uint32_t>(AnalogReadResponse::VT_PORT, port, 0);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(AnalogReadResponse::VT_VALUE, value, 0);
  }
  explicit AnalogReadResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnalogReadResponseBuilder &operator=(const AnalogReadResponseBuilder &);
  flatbuffers::Offset<AnalogReadResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnalogReadResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnalogReadResponse> CreateAnalogReadResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t port = 0,
    int32_t value = 0) {
  AnalogReadResponseBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_port(port);
  return builder_.Finish();
}

struct AnalogReadMultiRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REQUESTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<AnalogReadRequest>> *requests() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnalogReadRequest>> *>(VT_REQUESTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REQUESTS) &&
           verifier.VerifyVector(requests()) &&
           verifier.VerifyVectorOfTables(requests()) &&
           verifier.EndTable();
  }
};

struct AnalogReadMultiRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_requests(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnalogReadRequest>>> requests) {
    fbb_.AddOffset(AnalogReadMultiRequest::VT_REQUESTS, requests);
  }
  explicit AnalogReadMultiRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnalogReadMultiRequestBuilder &operator=(const AnalogReadMultiRequestBuilder &);
  flatbuffers::Offset<AnalogReadMultiRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnalogReadMultiRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnalogReadMultiRequest> CreateAnalogReadMultiRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnalogReadRequest>>> requests = 0) {
  AnalogReadMultiRequestBuilder builder_(_fbb);
  builder_.add_requests(requests);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnalogReadMultiRequest> CreateAnalogReadMultiRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AnalogReadRequest>> *requests = nullptr) {
  auto requests__ = requests ? _fbb.CreateVector<flatbuffers::Offset<AnalogReadRequest>>(*requests) : 0;
  return bbfrc::msgs::CreateAnalogReadMultiRequest(
      _fbb,
      requests__);
}

struct AnalogReadMultiResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESPONSES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<AnalogReadResponse>> *responses() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnalogReadResponse>> *>(VT_RESPONSES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RESPONSES) &&
           verifier.VerifyVector(responses()) &&
           verifier.VerifyVectorOfTables(responses()) &&
           verifier.EndTable();
  }
};

struct AnalogReadMultiResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_responses(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnalogReadResponse>>> responses) {
    fbb_.AddOffset(AnalogReadMultiResponse::VT_RESPONSES, responses);
  }
  explicit AnalogReadMultiResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnalogReadMultiResponseBuilder &operator=(const AnalogReadMultiResponseBuilder &);
  flatbuffers::Offset<AnalogReadMultiResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnalogReadMultiResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnalogReadMultiResponse> CreateAnalogReadMultiResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnalogReadResponse>>> responses = 0) {
  AnalogReadMultiResponseBuilder builder_(_fbb);
  builder_.add_responses(responses);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnalogReadMultiResponse> CreateAnalogReadMultiResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AnalogReadResponse>> *responses = nullptr) {
  auto responses__ = responses ? _fbb.CreateVector<flatbuffers::Offset<AnalogReadResponse>>(*responses) : 0;
  return bbfrc::msgs::CreateAnalogReadMultiResponse(
      _fbb,
      responses__);
}

struct AnalogReadSubscribeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PORT = 4,
    VT_SUBSCRIBE = 6
  };
  uint32_t port() const {
    return GetField<uint32_t>(VT_PORT, 0);
  }
  bool subscribe() const {
    return GetField<uint8_t>(VT_SUBSCRIBE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PORT) &&
           VerifyField<uint8_t>(verifier, VT_SUBSCRIBE) &&
           verifier.EndTable();
  }
};

struct AnalogReadSubscribeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_port(uint32_t port) {
    fbb_.AddElement<uint32_t>(AnalogReadSubscribeRequest::VT_PORT, port, 0);
  }
  void add_subscribe(bool subscribe) {
    fbb_.AddElement<uint8_t>(AnalogReadSubscribeRequest::VT_SUBSCRIBE, static_cast<uint8_t>(subscribe), 0);
  }
  explicit AnalogReadSubscribeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnalogReadSubscribeRequestBuilder &operator=(const AnalogReadSubscribeRequestBuilder &);
  flatbuffers::Offset<AnalogReadSubscribeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnalogReadSubscribeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnalogReadSubscribeRequest> CreateAnalogReadSubscribeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t port = 0,
    bool subscribe = false) {
  AnalogReadSubscribeRequestBuilder builder_(_fbb);
  builder_.add_port(port);
  builder_.add_subscribe(subscribe);
  return builder_.Finish();
}

struct AnalogReadSubscribeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORIGINALREQUEST = 4,
    VT_SUCCESS = 6
  };
  const AnalogReadSubscribeRequest *originalRequest() const {
    return GetPointer<const AnalogReadSubscribeRequest *>(VT_ORIGINALREQUEST);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ORIGINALREQUEST) &&
           verifier.VerifyTable(originalRequest()) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
};

struct AnalogReadSubscribeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_originalRequest(flatbuffers::Offset<AnalogReadSubscribeRequest> originalRequest) {
    fbb_.AddOffset(AnalogReadSubscribeResponse::VT_ORIGINALREQUEST, originalRequest);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(AnalogReadSubscribeResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit AnalogReadSubscribeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnalogReadSubscribeResponseBuilder &operator=(const AnalogReadSubscribeResponseBuilder &);
  flatbuffers::Offset<AnalogReadSubscribeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnalogReadSubscribeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnalogReadSubscribeResponse> CreateAnalogReadSubscribeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<AnalogReadSubscribeRequest> originalRequest = 0,
    bool success = false) {
  AnalogReadSubscribeResponseBuilder builder_(_fbb);
  builder_.add_originalRequest(originalRequest);
  builder_.add_success(success);
  return builder_.Finish();
}

struct AnalogReadSubscribeMultiRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REQUESTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<AnalogReadSubscribeRequest>> *requests() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnalogReadSubscribeRequest>> *>(VT_REQUESTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REQUESTS) &&
           verifier.VerifyVector(requests()) &&
           verifier.VerifyVectorOfTables(requests()) &&
           verifier.EndTable();
  }
};

struct AnalogReadSubscribeMultiRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_requests(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnalogReadSubscribeRequest>>> requests) {
    fbb_.AddOffset(AnalogReadSubscribeMultiRequest::VT_REQUESTS, requests);
  }
  explicit AnalogReadSubscribeMultiRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnalogReadSubscribeMultiRequestBuilder &operator=(const AnalogReadSubscribeMultiRequestBuilder &);
  flatbuffers::Offset<AnalogReadSubscribeMultiRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnalogReadSubscribeMultiRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnalogReadSubscribeMultiRequest> CreateAnalogReadSubscribeMultiRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnalogReadSubscribeRequest>>> requests = 0) {
  AnalogReadSubscribeMultiRequestBuilder builder_(_fbb);
  builder_.add_requests(requests);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnalogReadSubscribeMultiRequest> CreateAnalogReadSubscribeMultiRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AnalogReadSubscribeRequest>> *requests = nullptr) {
  auto requests__ = requests ? _fbb.CreateVector<flatbuffers::Offset<AnalogReadSubscribeRequest>>(*requests) : 0;
  return bbfrc::msgs::CreateAnalogReadSubscribeMultiRequest(
      _fbb,
      requests__);
}

struct AnalogReadSubscribeMultiResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESPONSES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<AnalogReadSubscribeResponse>> *responses() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnalogReadSubscribeResponse>> *>(VT_RESPONSES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RESPONSES) &&
           verifier.VerifyVector(responses()) &&
           verifier.VerifyVectorOfTables(responses()) &&
           verifier.EndTable();
  }
};

struct AnalogReadSubscribeMultiResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_responses(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnalogReadSubscribeResponse>>> responses) {
    fbb_.AddOffset(AnalogReadSubscribeMultiResponse::VT_RESPONSES, responses);
  }
  explicit AnalogReadSubscribeMultiResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnalogReadSubscribeMultiResponseBuilder &operator=(const AnalogReadSubscribeMultiResponseBuilder &);
  flatbuffers::Offset<AnalogReadSubscribeMultiResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnalogReadSubscribeMultiResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnalogReadSubscribeMultiResponse> CreateAnalogReadSubscribeMultiResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnalogReadSubscribeResponse>>> responses = 0) {
  AnalogReadSubscribeMultiResponseBuilder builder_(_fbb);
  builder_.add_responses(responses);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnalogReadSubscribeMultiResponse> CreateAnalogReadSubscribeMultiResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AnalogReadSubscribeResponse>> *responses = nullptr) {
  auto responses__ = responses ? _fbb.CreateVector<flatbuffers::Offset<AnalogReadSubscribeResponse>>(*responses) : 0;
  return bbfrc::msgs::CreateAnalogReadSubscribeMultiResponse(
      _fbb,
      responses__);
}

struct DigitalWriteRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PORT = 4,
    VT_VALUE = 6
  };
  uint32_t port() const {
    return GetField<uint32_t>(VT_PORT, 0);
  }
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PORT) &&
           VerifyField<uint8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DigitalWriteRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_port(uint32_t port) {
    fbb_.AddElement<uint32_t>(DigitalWriteRequest::VT_PORT, port, 0);
  }
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(DigitalWriteRequest::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit DigitalWriteRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DigitalWriteRequestBuilder &operator=(const DigitalWriteRequestBuilder &);
  flatbuffers::Offset<DigitalWriteRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DigitalWriteRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DigitalWriteRequest> CreateDigitalWriteRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t port = 0,
    bool value = false) {
  DigitalWriteRequestBuilder builder_(_fbb);
  builder_.add_port(port);
  builder_.add_value(value);
  return builder_.Finish();
}

struct DigitalReadRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PORT = 4
  };
  uint32_t port() const {
    return GetField<uint32_t>(VT_PORT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PORT) &&
           verifier.EndTable();
  }
};

struct DigitalReadRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_port(uint32_t port) {
    fbb_.AddElement<uint32_t>(DigitalReadRequest::VT_PORT, port, 0);
  }
  explicit DigitalReadRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DigitalReadRequestBuilder &operator=(const DigitalReadRequestBuilder &);
  flatbuffers::Offset<DigitalReadRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DigitalReadRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DigitalReadRequest> CreateDigitalReadRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t port = 0) {
  DigitalReadRequestBuilder builder_(_fbb);
  builder_.add_port(port);
  return builder_.Finish();
}

struct DigitalReadResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PORT = 4,
    VT_VALUE = 6
  };
  uint32_t port() const {
    return GetField<uint32_t>(VT_PORT, 0);
  }
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PORT) &&
           VerifyField<uint8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DigitalReadResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_port(uint32_t port) {
    fbb_.AddElement<uint32_t>(DigitalReadResponse::VT_PORT, port, 0);
  }
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(DigitalReadResponse::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit DigitalReadResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DigitalReadResponseBuilder &operator=(const DigitalReadResponseBuilder &);
  flatbuffers::Offset<DigitalReadResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DigitalReadResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DigitalReadResponse> CreateDigitalReadResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t port = 0,
    bool value = false) {
  DigitalReadResponseBuilder builder_(_fbb);
  builder_.add_port(port);
  builder_.add_value(value);
  return builder_.Finish();
}

struct DigitalReadMultiRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REQUESTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<DigitalReadRequest>> *requests() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DigitalReadRequest>> *>(VT_REQUESTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REQUESTS) &&
           verifier.VerifyVector(requests()) &&
           verifier.VerifyVectorOfTables(requests()) &&
           verifier.EndTable();
  }
};

struct DigitalReadMultiRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_requests(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DigitalReadRequest>>> requests) {
    fbb_.AddOffset(DigitalReadMultiRequest::VT_REQUESTS, requests);
  }
  explicit DigitalReadMultiRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DigitalReadMultiRequestBuilder &operator=(const DigitalReadMultiRequestBuilder &);
  flatbuffers::Offset<DigitalReadMultiRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DigitalReadMultiRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DigitalReadMultiRequest> CreateDigitalReadMultiRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DigitalReadRequest>>> requests = 0) {
  DigitalReadMultiRequestBuilder builder_(_fbb);
  builder_.add_requests(requests);
  return builder_.Finish();
}

inline flatbuffers::Offset<DigitalReadMultiRequest> CreateDigitalReadMultiRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<DigitalReadRequest>> *requests = nullptr) {
  auto requests__ = requests ? _fbb.CreateVector<flatbuffers::Offset<DigitalReadRequest>>(*requests) : 0;
  return bbfrc::msgs::CreateDigitalReadMultiRequest(
      _fbb,
      requests__);
}

struct DigitalReadMultiResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESPONSES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<DigitalReadResponse>> *responses() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DigitalReadResponse>> *>(VT_RESPONSES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RESPONSES) &&
           verifier.VerifyVector(responses()) &&
           verifier.VerifyVectorOfTables(responses()) &&
           verifier.EndTable();
  }
};

struct DigitalReadMultiResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_responses(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DigitalReadResponse>>> responses) {
    fbb_.AddOffset(DigitalReadMultiResponse::VT_RESPONSES, responses);
  }
  explicit DigitalReadMultiResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DigitalReadMultiResponseBuilder &operator=(const DigitalReadMultiResponseBuilder &);
  flatbuffers::Offset<DigitalReadMultiResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DigitalReadMultiResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DigitalReadMultiResponse> CreateDigitalReadMultiResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DigitalReadResponse>>> responses = 0) {
  DigitalReadMultiResponseBuilder builder_(_fbb);
  builder_.add_responses(responses);
  return builder_.Finish();
}

inline flatbuffers::Offset<DigitalReadMultiResponse> CreateDigitalReadMultiResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<DigitalReadResponse>> *responses = nullptr) {
  auto responses__ = responses ? _fbb.CreateVector<flatbuffers::Offset<DigitalReadResponse>>(*responses) : 0;
  return bbfrc::msgs::CreateDigitalReadMultiResponse(
      _fbb,
      responses__);
}

struct DigitalReadSubscribeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PORT = 4,
    VT_SUBSCRIBE = 6
  };
  uint32_t port() const {
    return GetField<uint32_t>(VT_PORT, 0);
  }
  bool subscribe() const {
    return GetField<uint8_t>(VT_SUBSCRIBE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PORT) &&
           VerifyField<uint8_t>(verifier, VT_SUBSCRIBE) &&
           verifier.EndTable();
  }
};

struct DigitalReadSubscribeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_port(uint32_t port) {
    fbb_.AddElement<uint32_t>(DigitalReadSubscribeRequest::VT_PORT, port, 0);
  }
  void add_subscribe(bool subscribe) {
    fbb_.AddElement<uint8_t>(DigitalReadSubscribeRequest::VT_SUBSCRIBE, static_cast<uint8_t>(subscribe), 0);
  }
  explicit DigitalReadSubscribeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DigitalReadSubscribeRequestBuilder &operator=(const DigitalReadSubscribeRequestBuilder &);
  flatbuffers::Offset<DigitalReadSubscribeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DigitalReadSubscribeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DigitalReadSubscribeRequest> CreateDigitalReadSubscribeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t port = 0,
    bool subscribe = false) {
  DigitalReadSubscribeRequestBuilder builder_(_fbb);
  builder_.add_port(port);
  builder_.add_subscribe(subscribe);
  return builder_.Finish();
}

struct DigitalReadSubscribeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORIGINALREQUEST = 4,
    VT_SUCCESS = 6
  };
  const DigitalReadSubscribeRequest *originalRequest() const {
    return GetPointer<const DigitalReadSubscribeRequest *>(VT_ORIGINALREQUEST);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ORIGINALREQUEST) &&
           verifier.VerifyTable(originalRequest()) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
};

struct DigitalReadSubscribeResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_originalRequest(flatbuffers::Offset<DigitalReadSubscribeRequest> originalRequest) {
    fbb_.AddOffset(DigitalReadSubscribeResponse::VT_ORIGINALREQUEST, originalRequest);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(DigitalReadSubscribeResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit DigitalReadSubscribeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DigitalReadSubscribeResponseBuilder &operator=(const DigitalReadSubscribeResponseBuilder &);
  flatbuffers::Offset<DigitalReadSubscribeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DigitalReadSubscribeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DigitalReadSubscribeResponse> CreateDigitalReadSubscribeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<DigitalReadSubscribeRequest> originalRequest = 0,
    bool success = false) {
  DigitalReadSubscribeResponseBuilder builder_(_fbb);
  builder_.add_originalRequest(originalRequest);
  builder_.add_success(success);
  return builder_.Finish();
}

struct DigitalReadSubscribeMultiRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REQUESTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<DigitalReadSubscribeRequest>> *requests() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DigitalReadSubscribeRequest>> *>(VT_REQUESTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REQUESTS) &&
           verifier.VerifyVector(requests()) &&
           verifier.VerifyVectorOfTables(requests()) &&
           verifier.EndTable();
  }
};

struct DigitalReadSubscribeMultiRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_requests(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DigitalReadSubscribeRequest>>> requests) {
    fbb_.AddOffset(DigitalReadSubscribeMultiRequest::VT_REQUESTS, requests);
  }
  explicit DigitalReadSubscribeMultiRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DigitalReadSubscribeMultiRequestBuilder &operator=(const DigitalReadSubscribeMultiRequestBuilder &);
  flatbuffers::Offset<DigitalReadSubscribeMultiRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DigitalReadSubscribeMultiRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DigitalReadSubscribeMultiRequest> CreateDigitalReadSubscribeMultiRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DigitalReadSubscribeRequest>>> requests = 0) {
  DigitalReadSubscribeMultiRequestBuilder builder_(_fbb);
  builder_.add_requests(requests);
  return builder_.Finish();
}

inline flatbuffers::Offset<DigitalReadSubscribeMultiRequest> CreateDigitalReadSubscribeMultiRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<DigitalReadSubscribeRequest>> *requests = nullptr) {
  auto requests__ = requests ? _fbb.CreateVector<flatbuffers::Offset<DigitalReadSubscribeRequest>>(*requests) : 0;
  return bbfrc::msgs::CreateDigitalReadSubscribeMultiRequest(
      _fbb,
      requests__);
}

struct DigitalReadSubscribeMultiResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESPONSES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<DigitalReadSubscribeResponse>> *responses() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DigitalReadSubscribeResponse>> *>(VT_RESPONSES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RESPONSES) &&
           verifier.VerifyVector(responses()) &&
           verifier.VerifyVectorOfTables(responses()) &&
           verifier.EndTable();
  }
};

struct DigitalReadSubscribeMultiResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_responses(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DigitalReadSubscribeResponse>>> responses) {
    fbb_.AddOffset(DigitalReadSubscribeMultiResponse::VT_RESPONSES, responses);
  }
  explicit DigitalReadSubscribeMultiResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DigitalReadSubscribeMultiResponseBuilder &operator=(const DigitalReadSubscribeMultiResponseBuilder &);
  flatbuffers::Offset<DigitalReadSubscribeMultiResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DigitalReadSubscribeMultiResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DigitalReadSubscribeMultiResponse> CreateDigitalReadSubscribeMultiResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DigitalReadSubscribeResponse>>> responses = 0) {
  DigitalReadSubscribeMultiResponseBuilder builder_(_fbb);
  builder_.add_responses(responses);
  return builder_.Finish();
}

inline flatbuffers::Offset<DigitalReadSubscribeMultiResponse> CreateDigitalReadSubscribeMultiResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<DigitalReadSubscribeResponse>> *responses = nullptr) {
  auto responses__ = responses ? _fbb.CreateVector<flatbuffers::Offset<DigitalReadSubscribeResponse>>(*responses) : 0;
  return bbfrc::msgs::CreateDigitalReadSubscribeMultiResponse(
      _fbb,
      responses__);
}

struct SetServoAngleRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERVOPIN = 4,
    VT_ANGLE = 6
  };
  uint32_t servoPin() const {
    return GetField<uint32_t>(VT_SERVOPIN, 0);
  }
  uint32_t angle() const {
    return GetField<uint32_t>(VT_ANGLE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SERVOPIN) &&
           VerifyField<uint32_t>(verifier, VT_ANGLE) &&
           verifier.EndTable();
  }
};

struct SetServoAngleRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_servoPin(uint32_t servoPin) {
    fbb_.AddElement<uint32_t>(SetServoAngleRequest::VT_SERVOPIN, servoPin, 0);
  }
  void add_angle(uint32_t angle) {
    fbb_.AddElement<uint32_t>(SetServoAngleRequest::VT_ANGLE, angle, 0);
  }
  explicit SetServoAngleRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SetServoAngleRequestBuilder &operator=(const SetServoAngleRequestBuilder &);
  flatbuffers::Offset<SetServoAngleRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetServoAngleRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SetServoAngleRequest> CreateSetServoAngleRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t servoPin = 0,
    uint32_t angle = 0) {
  SetServoAngleRequestBuilder builder_(_fbb);
  builder_.add_angle(angle);
  builder_.add_servoPin(servoPin);
  return builder_.Finish();
}

struct PinInformation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PHYSICALPIN = 4,
    VT_MODE = 6,
    VT_SUPPORTEDMODES = 8,
    VT_ANALOGCHANNEL = 10
  };
  uint32_t physicalPin() const {
    return GetField<uint32_t>(VT_PHYSICALPIN, 0);
  }
  PinMode mode() const {
    return static_cast<PinMode>(GetField<int8_t>(VT_MODE, 0));
  }
  const flatbuffers::Vector<int8_t> *supportedModes() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_SUPPORTEDMODES);
  }
  uint32_t analogChannel() const {
    return GetField<uint32_t>(VT_ANALOGCHANNEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PHYSICALPIN) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           VerifyOffset(verifier, VT_SUPPORTEDMODES) &&
           verifier.VerifyVector(supportedModes()) &&
           VerifyField<uint32_t>(verifier, VT_ANALOGCHANNEL) &&
           verifier.EndTable();
  }
};

struct PinInformationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_physicalPin(uint32_t physicalPin) {
    fbb_.AddElement<uint32_t>(PinInformation::VT_PHYSICALPIN, physicalPin, 0);
  }
  void add_mode(PinMode mode) {
    fbb_.AddElement<int8_t>(PinInformation::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  void add_supportedModes(flatbuffers::Offset<flatbuffers::Vector<int8_t>> supportedModes) {
    fbb_.AddOffset(PinInformation::VT_SUPPORTEDMODES, supportedModes);
  }
  void add_analogChannel(uint32_t analogChannel) {
    fbb_.AddElement<uint32_t>(PinInformation::VT_ANALOGCHANNEL, analogChannel, 0);
  }
  explicit PinInformationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PinInformationBuilder &operator=(const PinInformationBuilder &);
  flatbuffers::Offset<PinInformation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PinInformation>(end);
    return o;
  }
};

inline flatbuffers::Offset<PinInformation> CreatePinInformation(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t physicalPin = 0,
    PinMode mode = PinMode_OUTPUT,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> supportedModes = 0,
    uint32_t analogChannel = 0) {
  PinInformationBuilder builder_(_fbb);
  builder_.add_analogChannel(analogChannel);
  builder_.add_supportedModes(supportedModes);
  builder_.add_physicalPin(physicalPin);
  builder_.add_mode(mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<PinInformation> CreatePinInformationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t physicalPin = 0,
    PinMode mode = PinMode_OUTPUT,
    const std::vector<int8_t> *supportedModes = nullptr,
    uint32_t analogChannel = 0) {
  auto supportedModes__ = supportedModes ? _fbb.CreateVector<int8_t>(*supportedModes) : 0;
  return bbfrc::msgs::CreatePinInformation(
      _fbb,
      physicalPin,
      mode,
      supportedModes__,
      analogChannel);
}

struct GetPinInformationRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GetPinInformationRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GetPinInformationRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetPinInformationRequestBuilder &operator=(const GetPinInformationRequestBuilder &);
  flatbuffers::Offset<GetPinInformationRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetPinInformationRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetPinInformationRequest> CreateGetPinInformationRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GetPinInformationRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GetPinInformationResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOTALPHYSICALPINS = 4,
    VT_DIGITALPINS = 6,
    VT_ANALOGPINS = 8,
    VT_SERVOPINS = 10
  };
  uint32_t totalPhysicalPins() const {
    return GetField<uint32_t>(VT_TOTALPHYSICALPINS, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PinInformation>> *digitalPins() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PinInformation>> *>(VT_DIGITALPINS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PinInformation>> *analogPins() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PinInformation>> *>(VT_ANALOGPINS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PinInformation>> *servoPins() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PinInformation>> *>(VT_SERVOPINS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TOTALPHYSICALPINS) &&
           VerifyOffset(verifier, VT_DIGITALPINS) &&
           verifier.VerifyVector(digitalPins()) &&
           verifier.VerifyVectorOfTables(digitalPins()) &&
           VerifyOffset(verifier, VT_ANALOGPINS) &&
           verifier.VerifyVector(analogPins()) &&
           verifier.VerifyVectorOfTables(analogPins()) &&
           VerifyOffset(verifier, VT_SERVOPINS) &&
           verifier.VerifyVector(servoPins()) &&
           verifier.VerifyVectorOfTables(servoPins()) &&
           verifier.EndTable();
  }
};

struct GetPinInformationResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_totalPhysicalPins(uint32_t totalPhysicalPins) {
    fbb_.AddElement<uint32_t>(GetPinInformationResponse::VT_TOTALPHYSICALPINS, totalPhysicalPins, 0);
  }
  void add_digitalPins(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PinInformation>>> digitalPins) {
    fbb_.AddOffset(GetPinInformationResponse::VT_DIGITALPINS, digitalPins);
  }
  void add_analogPins(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PinInformation>>> analogPins) {
    fbb_.AddOffset(GetPinInformationResponse::VT_ANALOGPINS, analogPins);
  }
  void add_servoPins(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PinInformation>>> servoPins) {
    fbb_.AddOffset(GetPinInformationResponse::VT_SERVOPINS, servoPins);
  }
  explicit GetPinInformationResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetPinInformationResponseBuilder &operator=(const GetPinInformationResponseBuilder &);
  flatbuffers::Offset<GetPinInformationResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetPinInformationResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetPinInformationResponse> CreateGetPinInformationResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t totalPhysicalPins = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PinInformation>>> digitalPins = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PinInformation>>> analogPins = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PinInformation>>> servoPins = 0) {
  GetPinInformationResponseBuilder builder_(_fbb);
  builder_.add_servoPins(servoPins);
  builder_.add_analogPins(analogPins);
  builder_.add_digitalPins(digitalPins);
  builder_.add_totalPhysicalPins(totalPhysicalPins);
  return builder_.Finish();
}

inline flatbuffers::Offset<GetPinInformationResponse> CreateGetPinInformationResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t totalPhysicalPins = 0,
    const std::vector<flatbuffers::Offset<PinInformation>> *digitalPins = nullptr,
    const std::vector<flatbuffers::Offset<PinInformation>> *analogPins = nullptr,
    const std::vector<flatbuffers::Offset<PinInformation>> *servoPins = nullptr) {
  auto digitalPins__ = digitalPins ? _fbb.CreateVector<flatbuffers::Offset<PinInformation>>(*digitalPins) : 0;
  auto analogPins__ = analogPins ? _fbb.CreateVector<flatbuffers::Offset<PinInformation>>(*analogPins) : 0;
  auto servoPins__ = servoPins ? _fbb.CreateVector<flatbuffers::Offset<PinInformation>>(*servoPins) : 0;
  return bbfrc::msgs::CreateGetPinInformationResponse(
      _fbb,
      totalPhysicalPins,
      digitalPins__,
      analogPins__,
      servoPins__);
}

struct GetFirmwareNameAndVersionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GetFirmwareNameAndVersionRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GetFirmwareNameAndVersionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetFirmwareNameAndVersionRequestBuilder &operator=(const GetFirmwareNameAndVersionRequestBuilder &);
  flatbuffers::Offset<GetFirmwareNameAndVersionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetFirmwareNameAndVersionRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetFirmwareNameAndVersionRequest> CreateGetFirmwareNameAndVersionRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GetFirmwareNameAndVersionRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GetFirmwareNameAndVersionResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VERSIONMAJOR = 6,
    VT_VERSIONMINOR = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint8_t versionMajor() const {
    return GetField<uint8_t>(VT_VERSIONMAJOR, 0);
  }
  uint8_t versionMinor() const {
    return GetField<uint8_t>(VT_VERSIONMINOR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_VERSIONMAJOR) &&
           VerifyField<uint8_t>(verifier, VT_VERSIONMINOR) &&
           verifier.EndTable();
  }
};

struct GetFirmwareNameAndVersionResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GetFirmwareNameAndVersionResponse::VT_NAME, name);
  }
  void add_versionMajor(uint8_t versionMajor) {
    fbb_.AddElement<uint8_t>(GetFirmwareNameAndVersionResponse::VT_VERSIONMAJOR, versionMajor, 0);
  }
  void add_versionMinor(uint8_t versionMinor) {
    fbb_.AddElement<uint8_t>(GetFirmwareNameAndVersionResponse::VT_VERSIONMINOR, versionMinor, 0);
  }
  explicit GetFirmwareNameAndVersionResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GetFirmwareNameAndVersionResponseBuilder &operator=(const GetFirmwareNameAndVersionResponseBuilder &);
  flatbuffers::Offset<GetFirmwareNameAndVersionResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GetFirmwareNameAndVersionResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GetFirmwareNameAndVersionResponse> CreateGetFirmwareNameAndVersionResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint8_t versionMajor = 0,
    uint8_t versionMinor = 0) {
  GetFirmwareNameAndVersionResponseBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_versionMinor(versionMinor);
  builder_.add_versionMajor(versionMajor);
  return builder_.Finish();
}

inline flatbuffers::Offset<GetFirmwareNameAndVersionResponse> CreateGetFirmwareNameAndVersionResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint8_t versionMajor = 0,
    uint8_t versionMinor = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return bbfrc::msgs::CreateGetFirmwareNameAndVersionResponse(
      _fbb,
      name__,
      versionMajor,
      versionMinor);
}

struct SetDigitalPinModeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIGITALPIN = 4,
    VT_MODE = 6
  };
  uint32_t digitalPin() const {
    return GetField<uint32_t>(VT_DIGITALPIN, 0);
  }
  PinMode mode() const {
    return static_cast<PinMode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_DIGITALPIN) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           verifier.EndTable();
  }
};

struct SetDigitalPinModeRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_digitalPin(uint32_t digitalPin) {
    fbb_.AddElement<uint32_t>(SetDigitalPinModeRequest::VT_DIGITALPIN, digitalPin, 0);
  }
  void add_mode(PinMode mode) {
    fbb_.AddElement<int8_t>(SetDigitalPinModeRequest::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  explicit SetDigitalPinModeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SetDigitalPinModeRequestBuilder &operator=(const SetDigitalPinModeRequestBuilder &);
  flatbuffers::Offset<SetDigitalPinModeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetDigitalPinModeRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SetDigitalPinModeRequest> CreateSetDigitalPinModeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t digitalPin = 0,
    PinMode mode = PinMode_OUTPUT) {
  SetDigitalPinModeRequestBuilder builder_(_fbb);
  builder_.add_digitalPin(digitalPin);
  builder_.add_mode(mode);
  return builder_.Finish();
}

struct SystemResetRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SystemResetRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SystemResetRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SystemResetRequestBuilder &operator=(const SystemResetRequestBuilder &);
  flatbuffers::Offset<SystemResetRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SystemResetRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SystemResetRequest> CreateSystemResetRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SystemResetRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Envelope FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAYLOAD_TYPE = 4,
    VT_PAYLOAD = 6
  };
  Payload payload_type() const {
    return static_cast<Payload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const AnalogReadRequest *payload_as_AnalogReadRequest() const {
    return payload_type() == Payload_AnalogReadRequest ? static_cast<const AnalogReadRequest *>(payload()) : nullptr;
  }
  const AnalogReadResponse *payload_as_AnalogReadResponse() const {
    return payload_type() == Payload_AnalogReadResponse ? static_cast<const AnalogReadResponse *>(payload()) : nullptr;
  }
  const AnalogReadMultiRequest *payload_as_AnalogReadMultiRequest() const {
    return payload_type() == Payload_AnalogReadMultiRequest ? static_cast<const AnalogReadMultiRequest *>(payload()) : nullptr;
  }
  const AnalogReadMultiResponse *payload_as_AnalogReadMultiResponse() const {
    return payload_type() == Payload_AnalogReadMultiResponse ? static_cast<const AnalogReadMultiResponse *>(payload()) : nullptr;
  }
  const AnalogReadSubscribeRequest *payload_as_AnalogReadSubscribeRequest() const {
    return payload_type() == Payload_AnalogReadSubscribeRequest ? static_cast<const AnalogReadSubscribeRequest *>(payload()) : nullptr;
  }
  const AnalogReadSubscribeResponse *payload_as_AnalogReadSubscribeResponse() const {
    return payload_type() == Payload_AnalogReadSubscribeResponse ? static_cast<const AnalogReadSubscribeResponse *>(payload()) : nullptr;
  }
  const AnalogReadSubscribeMultiRequest *payload_as_AnalogReadSubscribeMultiRequest() const {
    return payload_type() == Payload_AnalogReadSubscribeMultiRequest ? static_cast<const AnalogReadSubscribeMultiRequest *>(payload()) : nullptr;
  }
  const AnalogReadSubscribeMultiResponse *payload_as_AnalogReadSubscribeMultiResponse() const {
    return payload_type() == Payload_AnalogReadSubscribeMultiResponse ? static_cast<const AnalogReadSubscribeMultiResponse *>(payload()) : nullptr;
  }
  const DigitalWriteRequest *payload_as_DigitalWriteRequest() const {
    return payload_type() == Payload_DigitalWriteRequest ? static_cast<const DigitalWriteRequest *>(payload()) : nullptr;
  }
  const DigitalReadRequest *payload_as_DigitalReadRequest() const {
    return payload_type() == Payload_DigitalReadRequest ? static_cast<const DigitalReadRequest *>(payload()) : nullptr;
  }
  const DigitalReadResponse *payload_as_DigitalReadResponse() const {
    return payload_type() == Payload_DigitalReadResponse ? static_cast<const DigitalReadResponse *>(payload()) : nullptr;
  }
  const DigitalReadMultiRequest *payload_as_DigitalReadMultiRequest() const {
    return payload_type() == Payload_DigitalReadMultiRequest ? static_cast<const DigitalReadMultiRequest *>(payload()) : nullptr;
  }
  const DigitalReadMultiResponse *payload_as_DigitalReadMultiResponse() const {
    return payload_type() == Payload_DigitalReadMultiResponse ? static_cast<const DigitalReadMultiResponse *>(payload()) : nullptr;
  }
  const DigitalReadSubscribeRequest *payload_as_DigitalReadSubscribeRequest() const {
    return payload_type() == Payload_DigitalReadSubscribeRequest ? static_cast<const DigitalReadSubscribeRequest *>(payload()) : nullptr;
  }
  const DigitalReadSubscribeResponse *payload_as_DigitalReadSubscribeResponse() const {
    return payload_type() == Payload_DigitalReadSubscribeResponse ? static_cast<const DigitalReadSubscribeResponse *>(payload()) : nullptr;
  }
  const DigitalReadSubscribeMultiRequest *payload_as_DigitalReadSubscribeMultiRequest() const {
    return payload_type() == Payload_DigitalReadSubscribeMultiRequest ? static_cast<const DigitalReadSubscribeMultiRequest *>(payload()) : nullptr;
  }
  const DigitalReadSubscribeMultiResponse *payload_as_DigitalReadSubscribeMultiResponse() const {
    return payload_type() == Payload_DigitalReadSubscribeMultiResponse ? static_cast<const DigitalReadSubscribeMultiResponse *>(payload()) : nullptr;
  }
  const SetServoAngleRequest *payload_as_SetServoAngleRequest() const {
    return payload_type() == Payload_SetServoAngleRequest ? static_cast<const SetServoAngleRequest *>(payload()) : nullptr;
  }
  const GetPinInformationRequest *payload_as_GetPinInformationRequest() const {
    return payload_type() == Payload_GetPinInformationRequest ? static_cast<const GetPinInformationRequest *>(payload()) : nullptr;
  }
  const GetPinInformationResponse *payload_as_GetPinInformationResponse() const {
    return payload_type() == Payload_GetPinInformationResponse ? static_cast<const GetPinInformationResponse *>(payload()) : nullptr;
  }
  const GetFirmwareNameAndVersionRequest *payload_as_GetFirmwareNameAndVersionRequest() const {
    return payload_type() == Payload_GetFirmwareNameAndVersionRequest ? static_cast<const GetFirmwareNameAndVersionRequest *>(payload()) : nullptr;
  }
  const GetFirmwareNameAndVersionResponse *payload_as_GetFirmwareNameAndVersionResponse() const {
    return payload_type() == Payload_GetFirmwareNameAndVersionResponse ? static_cast<const GetFirmwareNameAndVersionResponse *>(payload()) : nullptr;
  }
  const SetDigitalPinModeRequest *payload_as_SetDigitalPinModeRequest() const {
    return payload_type() == Payload_SetDigitalPinModeRequest ? static_cast<const SetDigitalPinModeRequest *>(payload()) : nullptr;
  }
  const SystemResetRequest *payload_as_SystemResetRequest() const {
    return payload_type() == Payload_SystemResetRequest ? static_cast<const SystemResetRequest *>(payload()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           VerifyPayload(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
};

template<> inline const AnalogReadRequest *Envelope::payload_as<AnalogReadRequest>() const {
  return payload_as_AnalogReadRequest();
}

template<> inline const AnalogReadResponse *Envelope::payload_as<AnalogReadResponse>() const {
  return payload_as_AnalogReadResponse();
}

template<> inline const AnalogReadMultiRequest *Envelope::payload_as<AnalogReadMultiRequest>() const {
  return payload_as_AnalogReadMultiRequest();
}

template<> inline const AnalogReadMultiResponse *Envelope::payload_as<AnalogReadMultiResponse>() const {
  return payload_as_AnalogReadMultiResponse();
}

template<> inline const AnalogReadSubscribeRequest *Envelope::payload_as<AnalogReadSubscribeRequest>() const {
  return payload_as_AnalogReadSubscribeRequest();
}

template<> inline const AnalogReadSubscribeResponse *Envelope::payload_as<AnalogReadSubscribeResponse>() const {
  return payload_as_AnalogReadSubscribeResponse();
}

template<> inline const AnalogReadSubscribeMultiRequest *Envelope::payload_as<AnalogReadSubscribeMultiRequest>() const {
  return payload_as_AnalogReadSubscribeMultiRequest();
}

template<> inline const AnalogReadSubscribeMultiResponse *Envelope::payload_as<AnalogReadSubscribeMultiResponse>() const {
  return payload_as_AnalogReadSubscribeMultiResponse();
}

template<> inline const DigitalWriteRequest *Envelope::payload_as<DigitalWriteRequest>() const {
  return payload_as_DigitalWriteRequest();
}

template<> inline const DigitalReadRequest *Envelope::payload_as<DigitalReadRequest>() const {
  return payload_as_DigitalReadRequest();
}

template<> inline const DigitalReadResponse *Envelope::payload_as<DigitalReadResponse>() const {
  return payload_as_DigitalReadResponse();
}

template<> inline const DigitalReadMultiRequest *Envelope::payload_as<DigitalReadMultiRequest>() const {
  return payload_as_DigitalReadMultiRequest();
}

template<> inline const DigitalReadMultiResponse *Envelope::payload_as<DigitalReadMultiResponse>() const {
  return payload_as_DigitalReadMultiResponse();
}

template<> inline const DigitalReadSubscribeRequest *Envelope::payload_as<DigitalReadSubscribeRequest>() const {
  return payload_as_DigitalReadSubscribeRequest();
}

template<> inline const DigitalReadSubscribeResponse *Envelope::payload_as<DigitalReadSubscribeResponse>() const {
  return payload_as_DigitalReadSubscribeResponse();
}

template<> inline const DigitalReadSubscribeMultiRequest *Envelope::payload_as<DigitalReadSubscribeMultiRequest>() const {
  return payload_as_DigitalReadSubscribeMultiRequest();
}

template<> inline const DigitalReadSubscribeMultiResponse *Envelope::payload_as<DigitalReadSubscribeMultiResponse>() const {
  return payload_as_DigitalReadSubscribeMultiResponse();
}

template<> inline const SetServoAngleRequest *Envelope::payload_as<SetServoAngleRequest>() const {
  return payload_as_SetServoAngleRequest();
}

template<> inline const GetPinInformationRequest *Envelope::payload_as<GetPinInformationRequest>() const {
  return payload_as_GetPinInformationRequest();
}

template<> inline const GetPinInformationResponse *Envelope::payload_as<GetPinInformationResponse>() const {
  return payload_as_GetPinInformationResponse();
}

template<> inline const GetFirmwareNameAndVersionRequest *Envelope::payload_as<GetFirmwareNameAndVersionRequest>() const {
  return payload_as_GetFirmwareNameAndVersionRequest();
}

template<> inline const GetFirmwareNameAndVersionResponse *Envelope::payload_as<GetFirmwareNameAndVersionResponse>() const {
  return payload_as_GetFirmwareNameAndVersionResponse();
}

template<> inline const SetDigitalPinModeRequest *Envelope::payload_as<SetDigitalPinModeRequest>() const {
  return payload_as_SetDigitalPinModeRequest();
}

template<> inline const SystemResetRequest *Envelope::payload_as<SystemResetRequest>() const {
  return payload_as_SystemResetRequest();
}

struct EnvelopeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_payload_type(Payload payload_type) {
    fbb_.AddElement<uint8_t>(Envelope::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(Envelope::VT_PAYLOAD, payload);
  }
  explicit EnvelopeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EnvelopeBuilder &operator=(const EnvelopeBuilder &);
  flatbuffers::Offset<Envelope> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Envelope>(end);
    return o;
  }
};

inline flatbuffers::Offset<Envelope> CreateEnvelope(
    flatbuffers::FlatBufferBuilder &_fbb,
    Payload payload_type = Payload_NONE,
    flatbuffers::Offset<void> payload = 0) {
  EnvelopeBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

inline bool VerifyPayload(flatbuffers::Verifier &verifier, const void *obj, Payload type) {
  switch (type) {
    case Payload_NONE: {
      return true;
    }
    case Payload_AnalogReadRequest: {
      auto ptr = reinterpret_cast<const AnalogReadRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_AnalogReadResponse: {
      auto ptr = reinterpret_cast<const AnalogReadResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_AnalogReadMultiRequest: {
      auto ptr = reinterpret_cast<const AnalogReadMultiRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_AnalogReadMultiResponse: {
      auto ptr = reinterpret_cast<const AnalogReadMultiResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_AnalogReadSubscribeRequest: {
      auto ptr = reinterpret_cast<const AnalogReadSubscribeRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_AnalogReadSubscribeResponse: {
      auto ptr = reinterpret_cast<const AnalogReadSubscribeResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_AnalogReadSubscribeMultiRequest: {
      auto ptr = reinterpret_cast<const AnalogReadSubscribeMultiRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_AnalogReadSubscribeMultiResponse: {
      auto ptr = reinterpret_cast<const AnalogReadSubscribeMultiResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_DigitalWriteRequest: {
      auto ptr = reinterpret_cast<const DigitalWriteRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_DigitalReadRequest: {
      auto ptr = reinterpret_cast<const DigitalReadRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_DigitalReadResponse: {
      auto ptr = reinterpret_cast<const DigitalReadResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_DigitalReadMultiRequest: {
      auto ptr = reinterpret_cast<const DigitalReadMultiRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_DigitalReadMultiResponse: {
      auto ptr = reinterpret_cast<const DigitalReadMultiResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_DigitalReadSubscribeRequest: {
      auto ptr = reinterpret_cast<const DigitalReadSubscribeRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_DigitalReadSubscribeResponse: {
      auto ptr = reinterpret_cast<const DigitalReadSubscribeResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_DigitalReadSubscribeMultiRequest: {
      auto ptr = reinterpret_cast<const DigitalReadSubscribeMultiRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_DigitalReadSubscribeMultiResponse: {
      auto ptr = reinterpret_cast<const DigitalReadSubscribeMultiResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_SetServoAngleRequest: {
      auto ptr = reinterpret_cast<const SetServoAngleRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_GetPinInformationRequest: {
      auto ptr = reinterpret_cast<const GetPinInformationRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_GetPinInformationResponse: {
      auto ptr = reinterpret_cast<const GetPinInformationResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_GetFirmwareNameAndVersionRequest: {
      auto ptr = reinterpret_cast<const GetFirmwareNameAndVersionRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_GetFirmwareNameAndVersionResponse: {
      auto ptr = reinterpret_cast<const GetFirmwareNameAndVersionResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_SetDigitalPinModeRequest: {
      auto ptr = reinterpret_cast<const SetDigitalPinModeRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_SystemResetRequest: {
      auto ptr = reinterpret_cast<const SystemResetRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyPayloadVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPayload(
        verifier,  values->Get(i), types->GetEnum<Payload>(i))) {
      return false;
    }
  }
  return true;
}

inline const bbfrc::msgs::Envelope *GetEnvelope(const void *buf) {
  return flatbuffers::GetRoot<bbfrc::msgs::Envelope>(buf);
}

inline const bbfrc::msgs::Envelope *GetSizePrefixedEnvelope(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<bbfrc::msgs::Envelope>(buf);
}

inline bool VerifyEnvelopeBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<bbfrc::msgs::Envelope>(nullptr);
}

inline bool VerifySizePrefixedEnvelopeBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<bbfrc::msgs::Envelope>(nullptr);
}

inline void FinishEnvelopeBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<bbfrc::msgs::Envelope> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedEnvelopeBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<bbfrc::msgs::Envelope> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace msgs
}  // namespace bbfrc

#endif  // FLATBUFFERS_GENERATED_DRIVETHRU_BBFRC_MSGS_H_
